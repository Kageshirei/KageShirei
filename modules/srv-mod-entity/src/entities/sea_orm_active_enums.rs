//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

use crate::entities::agent;

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "agent_field")]
pub enum AgentField {
    #[sea_orm(string_value = "agent")]
    Agent,
    #[sea_orm(string_value = "created_at")]
    CreatedAt,
    #[sea_orm(string_value = "cwd")]
    Cwd,
    #[sea_orm(string_value = "domain")]
    Domain,
    #[sea_orm(string_value = "hostname")]
    Hostname,
    #[sea_orm(string_value = "id")]
    Id,
    #[sea_orm(string_value = "integrity")]
    Integrity,
    #[sea_orm(string_value = "network_interfaces")]
    NetworkInterfaces,
    #[sea_orm(string_value = "operating_system")]
    OperatingSystem,
    #[sea_orm(string_value = "pid")]
    Pid,
    #[sea_orm(string_value = "ppid")]
    Ppid,
    #[sea_orm(string_value = "process_name")]
    ProcessName,
    #[sea_orm(string_value = "secret")]
    Secret,
    #[sea_orm(string_value = "server_secret")]
    ServerSecret,
    #[sea_orm(string_value = "signature")]
    Signature,
    #[sea_orm(string_value = "terminated_at")]
    TerminatedAt,
    #[sea_orm(string_value = "updated_at")]
    UpdatedAt,
    #[sea_orm(string_value = "username")]
    Username,
}
impl From<agent::Column> for AgentField {
    fn from(column: agent::Column) -> Self {
        match column {
            agent::Column::CreatedAt => Self::CreatedAt,
            agent::Column::Cwd => Self::Cwd,
            agent::Column::Domain => Self::Domain,
            agent::Column::Hostname => Self::Hostname,
            agent::Column::Id => Self::Id,
            agent::Column::Integrity => Self::Integrity,
            agent::Column::NetworkInterfaces => Self::NetworkInterfaces,
            agent::Column::OperatingSystem => Self::OperatingSystem,
            agent::Column::Pid => Self::Pid,
            agent::Column::Ppid => Self::Ppid,
            agent::Column::ProcessName => Self::ProcessName,
            agent::Column::Secret => Self::Secret,
            agent::Column::ServerSecret => Self::ServerSecret,
            agent::Column::Signature => Self::Signature,
            agent::Column::TerminatedAt => Self::TerminatedAt,
            agent::Column::UpdatedAt => Self::UpdatedAt,
            agent::Column::Username => Self::Username,
        }
    }
}
impl From<AgentField> for agent::Column {
    fn from(val: AgentField) -> Self {
        match val {
            AgentField::CreatedAt => Self::CreatedAt,
            AgentField::Cwd => Self::Cwd,
            AgentField::Domain => Self::Domain,
            AgentField::Hostname => Self::Hostname,
            AgentField::Id => Self::Id,
            AgentField::Integrity => Self::Integrity,
            AgentField::NetworkInterfaces => Self::NetworkInterfaces,
            AgentField::OperatingSystem => Self::OperatingSystem,
            AgentField::Pid => Self::Pid,
            AgentField::Ppid => Self::Ppid,
            AgentField::ProcessName => Self::ProcessName,
            AgentField::Secret => Self::Secret,
            AgentField::ServerSecret => Self::ServerSecret,
            AgentField::Signature => Self::Signature,
            AgentField::TerminatedAt => Self::TerminatedAt,
            AgentField::UpdatedAt => Self::UpdatedAt,
            AgentField::Username => Self::Username,
            AgentField::Agent => Self::Id, // This is the Table alias used in the migration
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "agent_integrity")]
pub enum AgentIntegrity {
    #[sea_orm(string_value = "high")]
    High,
    #[sea_orm(string_value = "invalid")]
    Invalid,
    #[sea_orm(string_value = "low")]
    Low,
    #[sea_orm(string_value = "medium")]
    Medium,
    #[sea_orm(string_value = "protected_process")]
    ProtectedProcess,
    #[sea_orm(string_value = "system")]
    System,
    #[sea_orm(string_value = "untrusted")]
    Untrusted,
}

impl From<i16> for AgentIntegrity {
    fn from(value: i16) -> Self {
        match value {
            0x0000 => Self::Untrusted,
            0x1000 => Self::Low,
            0x2000 => Self::Medium,
            0x3000 => Self::High,
            0x4000 => Self::System,
            0x5000 => Self::ProtectedProcess,
            _ => Self::Invalid,
        }
    }
}

impl From<AgentIntegrity> for i16 {
    fn from(val: AgentIntegrity) -> Self {
        match val {
            AgentIntegrity::Untrusted => 0x0000,
            AgentIntegrity::Low => 0x1000,
            AgentIntegrity::Medium => 0x2000,
            AgentIntegrity::High => 0x3000,
            AgentIntegrity::System => 0x4000,
            AgentIntegrity::ProtectedProcess => 0x5000,
            AgentIntegrity::Invalid => Self::MAX,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "command_status")]
pub enum CommandStatus {
    #[sea_orm(string_value = "completed")]
    Completed,
    #[sea_orm(string_value = "failed")]
    Failed,
    #[sea_orm(string_value = "pending")]
    Pending,
    #[sea_orm(string_value = "running")]
    Running,
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "filter_operation")]
pub enum FilterOperation {
    #[sea_orm(string_value = "contains")]
    Contains,
    #[sea_orm(string_value = "ends_with")]
    EndsWith,
    #[sea_orm(string_value = "equals")]
    Equals,
    #[sea_orm(string_value = "not_contains")]
    NotContains,
    #[sea_orm(string_value = "not_equals")]
    NotEquals,
    #[sea_orm(string_value = "starts_with")]
    StartsWith,
}
impl From<String> for FilterOperation {
    fn from(value: String) -> Self {
        match value.as_str() {
            "contains" => Self::Contains,
            "ends_with" => Self::EndsWith,
            "equals" => Self::Equals,
            "not_contains" => Self::NotContains,
            "not_equals" => Self::NotEquals,
            "starts_with" => Self::StartsWith,
            _ => Self::Equals,
        }
    }
}
impl From<FilterOperation> for String {
    fn from(val: FilterOperation) -> Self {
        match val {
            FilterOperation::Contains => "contains".to_owned(),
            FilterOperation::EndsWith => "ends_with".to_owned(),
            FilterOperation::Equals => "equals".to_owned(),
            FilterOperation::NotContains => "not_contains".to_owned(),
            FilterOperation::NotEquals => "not_equals".to_owned(),
            FilterOperation::StartsWith => "starts_with".to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "log_level")]
pub enum LogLevel {
    #[sea_orm(string_value = "debug")]
    Debug,
    #[sea_orm(string_value = "error")]
    Error,
    #[sea_orm(string_value = "info")]
    Info,
    #[sea_orm(string_value = "trace")]
    Trace,
    #[sea_orm(string_value = "warning")]
    Warning,
}
impl From<String> for LogLevel {
    fn from(value: String) -> Self {
        match value.as_str() {
            "debug" => Self::Debug,
            "error" => Self::Error,
            "info" => Self::Info,
            "trace" => Self::Trace,
            "warning" => Self::Warning,
            _ => Self::Info,
        }
    }
}
impl From<LogLevel> for String {
    fn from(val: LogLevel) -> Self {
        match val {
            LogLevel::Debug => "debug".to_owned(),
            LogLevel::Error => "error".to_owned(),
            LogLevel::Info => "info".to_owned(),
            LogLevel::Trace => "trace".to_owned(),
            LogLevel::Warning => "warning".to_owned(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "logical_operator")]
pub enum LogicalOperator {
    #[sea_orm(string_value = "and")]
    And,
    #[sea_orm(string_value = "or")]
    Or,
}
impl From<String> for LogicalOperator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "and" => Self::And,
            "or" => Self::Or,
            _ => Self::And,
        }
    }
}
impl From<LogicalOperator> for String {
    fn from(val: LogicalOperator) -> Self {
        match val {
            LogicalOperator::And => "and".to_owned(),
            LogicalOperator::Or => "or".to_owned(),
        }
    }
}
